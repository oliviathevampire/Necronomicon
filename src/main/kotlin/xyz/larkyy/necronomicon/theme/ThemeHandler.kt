package xyz.larkyy.necronomicon.theme

import org.bukkit.NamespacedKey
import org.bukkit.inventory.ItemStack
import org.bukkit.persistence.PersistentDataType
import xyz.larkyy.necronomicon.NecroNomicon

class ThemeHandler(plugin: NecroNomicon) {

    private val namespacedKey: NamespacedKey
    val themes: MutableMap<String, Theme> = HashMap()

    init {
        this.namespacedKey = NamespacedKey(plugin, "theme-id")
        for (value in plugin.configLoader.loadThemes().values) {
            createTheme(value.id, value.itemStack, value.value, value.length)
        }
    }

    fun isTheme(item: ItemStack): Boolean {
        val im = item.itemMeta ?: return false
        val pdc = im.persistentDataContainer
        if (!pdc.has(namespacedKey)) return false
        val id = pdc.get(namespacedKey, PersistentDataType.STRING) ?: return false
        return isTheme(id)
    }

    fun isTheme(id: String): Boolean {
        return themes.containsKey(id)
    }

    fun getTheme(id: String): Theme? {
        return themes[id]
    }

    fun getTheme(item: ItemStack): Theme? {
        val im = item.itemMeta ?: return null
        val pdc = im.persistentDataContainer
        if (!pdc.has(namespacedKey)) return null
        val id = pdc.get(namespacedKey, PersistentDataType.STRING) ?: return null
        return themes[id]
    }

    fun createTheme(id: String, item: ItemStack, value: String, length: Int) {
        val im = item.itemMeta ?: return
        val pdc = im.persistentDataContainer
        pdc.set(namespacedKey, PersistentDataType.STRING, id)
        item.setItemMeta(im)

        themes[id] = Theme(id, item, value, length)
    }
}